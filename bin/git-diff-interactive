#! /usr/bin/env bash

branch_glyph=''
div=$' │ '
repo="$(git rev-parse --show-toplevel)"
head="$(git rev-parse --short HEAD)"
branch="$(git rev-parse --abbrev-ref HEAD)"
last="$(git --no-pager log --format='%h: %s' -n 1 HEAD)"
filter="${DIFFFILTER:-$(git config --global interactive.difffilter)}"
title="${1}${1:+$div}${branch_glyph} ${branch}${div}${last}"
optfile="${TMPDIR:-/tmp}/git-diff-interactive.$$.sh"

cat << EOF > "$optfile"
# temp file sourced by git-diff-interactive
gdi_show_staged=y
gdi_show_unstaged=y
gdi_show_untracked=y
gdi_debug_variables=n
EOF

join() {
    IFS=$1; shift; echo "$*"
}

load_state() {
    [ -r "${optfile}" ] && source "${optfile}" || :
}

get_diff() {
    load_state
    [[ $gdi_show_staged == 'y' ]] && git diff --name-only --cached | sed 's/^.*$/S\x00&/g'
    [[ $gdi_show_unstaged == 'y' ]] && git diff --name-only | sed 's/^.*$/U\x00&/g'
    [[ $gdi_show_untracked == 'y' ]] && git -C "${repo}" ls-files --others --exclude-standard | sed 's/^.*$/?\x00&/g' || :
}

print_file_stats() {
    local state="$1"
    local file="${repo}/${2}"
    if [[ -z "${file}" ]]; then
        echo '<no file selected>'
    elif [[ $state == '?' ]]; then
        # file is untracked
        echo '<new file>'
    elif [[ $state == 'S' ]]; then
        # file is staged, get cached diff
        printf 'staged:'
        git diff --color=always --stat --cached -- "${file}" | tail -n1 | cut -d, -f 2-
    elif [[ $state == 'U' ]]; then
        # want unstaged diff
        printf 'unstaged:'
        git diff --color=always --stat -- "${file}" | tail -n1 | cut -d, -f 2-
    else
        printf 'ERROR: invalid state: %s' "${state}"
fi
}

toggle_show() {
    load_state
    declare -n show="gdi_show_$1"
    [[ "$show" == 'y' ]] && show=n || show=y
    sed -i "s/^${!show}=.*$/${!show}=${show}/" "${optfile}"
    echo 'reload(get_diff)+trigger(focus)'
}

toggle_debug_vars() {
    load_state
    [[ $gdi_debug_variables == 'y' ]] && value=n || value=y
    sed -i "s/^gdi_debug_variables=.*$/gdi_debug_variables=${value}/" "${optfile}"
    echo 'trigger(focus)'
}

toggle_select_all() {
    [ "$FZF_SELECT_COUNT" == "0" ] && echo "select-all" || echo "deselect-all"
}

print_keys() {
    printf '<ctrl-e>:     show nvim\n'
    printf '<ctrl-r>:     refresh list\n'
    printf '<shift-tab>:  toggle all\n'
    printf '<alt-1>:      toggle staged\n'
    printf '<alt-2>:      toggle unstaged\n'
    printf '<alt-3>:      toggle untracked\n'
    printf '<alt-d>:      debug variables\n'
}

print_preview() {
    local state="$1"
    local file="${repo}/${2}"
    if [[ $state == '?' ]]; then
        # file is untracked
        bat --style numbers,header-filename,header-filesize --color always --paging never "${file}"
    elif [[ $state == 'S' ]]; then
        # file is staged, get cached diff
        git diff --color=always --cached -- "${file}" | ${filter:-less -R}
    elif [[ $state == 'U' ]]; then
        # file is unstaged
        git diff --color=always -- "${file}" | ${filter:-less -R}
    else
        printf "ERROR: don't know what to show for file\n"
        printf "file:    %s\n" "${file}"
        printf "state:   %s\n" "${state}"
    fi
}

open_in_nvim() {
    local files=("$@")
    for f in "${files[@]}"; do
        absfiles+=("${repo}/$f")
    done
    if [[ -n "${TMUX}" ]]; then
        # start in tmux popup
        tmux display-popup -E -d "${repo}" -h 75% -w 75% -b heavy nvim "${absfiles[@]}"
    else
        nvim "${absfiles[@]}"
    fi
}

transform_update_ui() {
    load_state
    local state="$1"
    local file="$2"
    local footer="$([[ "$gdi_debug_variables" == 'y' ]] && declare | grep -E '(^FZF_|^gdi_)' | sort; print_keys)"
    if [[ -n "$file" ]]; then
        local stats="$(print_file_stats "$state" "$file")"
        if [[ -n "$stats" ]]; then
            printf -v statinfo '┤ %s ├' "${stats}"
        fi
    fi
    local show=()
    for state in staged unstaged untracked; do
        v=gdi_show_$state
        [[ ${!v} == 'y' ]] && show+=($state)
    done
    if [[ "${#show[@]}" == '0' ]]; then
        printf -v listlabel '┤ <nothing to show> ├'
    else
        printf -v listlabel '┤ Showing: %s ├' "$( join + ${show[*]} )"
    fi
    echo "change-preview-label($statinfo)+change-footer($footer)+change-list-label($listlabel)"
}

export repo
export filter
export optfile
export -f load_state
export -f join
export -f toggle_select_all
export -f get_diff
export -f print_keys
export -f print_preview
export -f print_file_stats
export -f transform_update_ui
export -f toggle_show
export -f toggle_debug_vars
export -f open_in_nvim

fzf --preview "print_preview {1} {2}" \
    --ansi \
    --reverse \
    --cycle \
    --multi \
    --delimiter '\x00' \
    --with-nth '{1}: {2}' \
    --accept-nth '{2}' \
    --border 'rounded' \
    --style full \
    --preview-border 'rounded' \
    --preview-label-pos '-3' \
    --input-border 'none' \
    --list-label-pos 3 \
    --footer-border 'rounded' \
    --footer-label '┤ Bindings ├' \
    --footer-label-pos 3 \
    --footer "FOOTER" \
    --info 'inline-right' \
    --no-separator \
    --preview-window=right,75%,wrap \
    --border-label "┤ ${title} ├" \
    --padding 0 \
    --bind "ctrl-e:execute${TMUX:+-silent}(open_in_nvim {+2})" \
    --bind "start:trigger(focus)+reload(get_diff)" \
    --bind "ctrl-r,f5:reload(get_diff)" \
    --bind "focus:transform:transform_update_ui {1} {2}" \
    --bind "alt-1:transform:toggle_show staged" \
    --bind "alt-2:transform:toggle_show unstaged" \
    --bind "alt-3:transform:toggle_show untracked" \
    --bind "alt-d:transform:toggle_debug_vars" \
    --bind "shift-tab:transform:toggle_select_all" \
    --bind "shift-tab:+trigger(focus)" \
    --color 'border:#cccccc:bold,label:#cccccc:bold' \
    --color 'list-border:#26c485,list-label:#26c485' \
    --color 'preview-border:#ccccff:regular,preview-label:#ccccff:regular' \
    --color 'footer-border:#6699cc,footer-label:#6699cc' \
    --color 'input-label:#84c757,input-border:#84c757' \

rm -f "$optfile" &>/dev/null
